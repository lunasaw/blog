(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{707:function(t,e,o){"use strict";o.r(e);var v=o(7),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[t._v("首先，主题已经将某篇文章的侧边栏抽离出来放在右边，被称为「子侧边栏」；左边的侧边栏的仅会在自定义侧边栏时显示，它所显示的知识文章的分类和目录，我们称它为「原侧边栏」。")]),t._v(" "),o("p",[t._v("其次，默认主题的本身的 API "),o("code",[t._v("sidebar")]),t._v(" 有双重含义：")]),t._v(" "),o("ul",[o("li",[t._v("当给其设置为 "),o("code",[t._v("auto")]),t._v(" 值时，它会使用每篇文章的标题生成左侧侧边栏；")]),t._v(" "),o("li",[t._v("当我们配置自定义侧边栏时，配置进去的文章会形成分类侧边栏，并且文章的标题也会显示在其中；而没有配置进去文章在访问时，是没有侧边栏的。")])]),t._v(" "),o("p",[t._v("所以决定将自定义侧边栏形成的对文章目录的分类和文章本身的标题形成的侧边栏进行分离，也就形成了现在的「原侧边栏」和「子侧边栏」。因此，当设置 "),o("code",[t._v("sidebar: 'auto'")]),t._v(" 的时候，其实已经没有上面提到的第一层含义了，因为已经不能控制生成文章的左侧侧边栏了。")])])}),[],!1,null,null,null);e.default=_.exports}}]);